# Архитектура проекта

## Общий обзор

Приложение использует современную архитектуру с разделением на клиентскую и серверную части. Ниже описаны основные архитектурные решения и паттерны, используемые в проекте.

## Архитектурные компоненты

### 1. Клиент-серверная архитектура

Проект построен по принципу клиент-серверной архитектуры:
- **Клиент (Frontend)**: React-приложение, отвечающее за пользовательский интерфейс
- **Сервер (Backend)**: Express-сервер, предоставляющий API и взаимодействующий с базой данных

### 2. Схема взаимодействия компонентов

```
┌─────────────────┐           ┌─────────────────┐           ┌─────────────────┐
│                 │           │                 │           │                 │
│    Frontend     │◄─────────►│     Backend     │◄─────────►│    Database     │
│     (React)     │  HTTP API │    (Express)    │   SQL     │  (PostgreSQL)   │
│                 │           │                 │           │                 │
└─────────────────┘           └─────────────────┘           └─────────────────┘
```

### 3. Слои приложения

#### Frontend

1. **Presentation Layer** (компоненты React):
   - Страницы (`pages/`)
   - Компоненты пользовательского интерфейса (`components/`)
   - UI библиотека (shadcn/ui)

2. **State Management Layer**:
   - React Query для управления состоянием и кэширования данных
   - React useState/useContext для локального состояния компонентов

3. **Service Layer**:
   - API-клиент для взаимодействия с бэкендом (`lib/queryClient.ts`)
   - Утилиты и вспомогательные функции (`lib/utils.ts`)

#### Backend

1. **API Layer** (контроллеры):
   - Определение маршрутов и обработчиков запросов (`routes.ts`)
   - Валидация входящих данных (использование Zod-схем)

2. **Service Layer**:
   - Бизнес-логика и координация операций
   - Интерфейс хранилища (`IStorage`)

3. **Data Access Layer**:
   - Реализация хранилища (`DatabaseStorage`)
   - ORM (Drizzle) для взаимодействия с базой данных

4. **Database Layer**:
   - PostgreSQL база данных
   - Схема базы данных (`schema.ts`)

### 4. Основные паттерны проектирования

#### Repository Pattern

Для абстрагирования доступа к данным используется паттерн Repository, реализованный через интерфейс `IStorage` и класс `DatabaseStorage`. Это позволяет:

- Изолировать бизнес-логику от деталей хранения данных
- Упростить тестирование, подменяя реализацию хранилища
- Добавлять новые источники данных без изменения бизнес-логики

```typescript
export interface IStorage {
  // методы для работы с данными
}

export class DatabaseStorage implements IStorage {
  // реализация методов с использованием базы данных
}
```

#### Dependency Injection

Внедрение зависимостей используется для передачи экземпляра хранилища в обработчики маршрутов:

```typescript
export const storage = new DatabaseStorage();

export async function registerRoutes(app: Express) {
  // Использование хранилища в маршрутах
  app.get('/api/endpoint', async (req, res) => {
    const data = await storage.getData();
    // ...
  });
}
```

#### Frontend Component Pattern

На клиентской стороне используется компонентный подход с разделением на:

- **Containers**: Компоненты, содержащие бизнес-логику и состояние (страницы)
- **Presentational Components**: Компоненты, отвечающие только за отображение данных (UI-компоненты)
- **Hooks**: Переиспользуемая логика (пользовательские хуки)

## Обработка данных

### Поток данных

1. **Пользовательский ввод** → Frontend компоненты
2. Frontend → **Backend API** (HTTP-запрос)
3. Backend API → **Валидация данных** (Zod)
4. Валидация → **Бизнес-логика** (Storage Interface)
5. Бизнес-логика → **База данных** (Drizzle ORM)
6. База данных → **Ответ** → Frontend
7. Frontend → **Обновление UI**

### Валидация данных

Валидация выполняется на нескольких уровнях:

1. **Frontend**: Валидация форм с использованием React Hook Form и Zod
2. **Backend**: Валидация входящих данных с использованием Zod-схем
3. **База данных**: Ограничения на уровне схемы базы данных

## Безопасность

### Аутентификация и авторизация

- Простая аутентификация на основе логина и пароля для административных функций
- Проверка авторизации через middleware для защищенных маршрутов
- Хранение хешированных паролей в базе данных

### Защита от распространенных уязвимостей

- **SQL-инъекции**: Использование ORM (Drizzle) с параметризованными запросами
- **XSS**: Правильная обработка пользовательского ввода на клиенте и сервере
- **CSRF**: Использование токенов для защиты от подделки межсайтовых запросов

## Масштабируемость

Архитектура проекта позволяет масштабировать приложение:

- Модульная структура кода
- Четкое разделение ответственности между компонентами
- Возможность замены компонентов без изменения всей архитектуры

## Будущие улучшения архитектуры

1. **Микросервисная архитектура**: Разделение серверной части на независимые сервисы
2. **CQRS (Command Query Responsibility Segregation)**: Разделение операций чтения и записи
3. **Event Sourcing**: Сохранение всех изменений состояния как последовательности событий
4. **Расширенное кэширование**: Добавление Redis для кэширования часто запрашиваемых данных

## Технический долг и компромиссы

1. **Простая аутентификация**: Используется простая схема логин/пароль вместо более безопасных методов (OAuth, JWT)
2. **Монолитная архитектура**: Вся бизнес-логика в одном сервисе
3. **Управление состоянием**: Отсутствие централизованного управления состоянием на клиенте (например, Redux, MobX)

Эти компромиссы были сделаны для ускорения разработки первой версии приложения и могут быть пересмотрены в будущих версиях.